/*
 * This file is part of Peli - universal JSON interaction library
 * Copyright (C) 2014  Alexey Chernov <4ernov@gmail.com>
 *
 * Peli is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, see <http://www.gnu.org/licenses/>.
 *
 */

/* The following UTF conversion routines use several parts of code of UTF8-CPP
 * project <http://utfcpp.sourceforge.net/>.
 *
 * UTF8-CPP copyright 2006 Nemanja Trifunovic
 *
 * UTF8-CPP license reads:
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
*/


#include "utf.h"

#include <type_traits>
#include <stdexcept>

namespace utf = peli::json::detail::parser::utf;
using namespace peli::json::detail::parser::utf;

using namespace std;

namespace
{
	// Unicode constants
	// Leading (high) surrogates: 0xd800 - 0xdbff
	// Trailing (low) surrogates: 0xdc00 - 0xdfff
	const uint16_t LEAD_SURROGATE_MIN  = 0xd800u;
	const uint16_t LEAD_SURROGATE_MAX  = 0xdbffu;
	const uint16_t TRAIL_SURROGATE_MIN = 0xdc00u;
	const uint16_t TRAIL_SURROGATE_MAX = 0xdfffu;
	const uint16_t LEAD_OFFSET         = LEAD_SURROGATE_MIN - (0x10000 >> 10);
	const uint32_t SURROGATE_OFFSET    = 0x10000u - (LEAD_SURROGATE_MIN << 10) - TRAIL_SURROGATE_MIN;

	// Maximum valid value for a Unicode code point
	const uint32_t CODE_POINT_MAX      = 0x0010ffffu;

	template <typename u16>
	inline bool is_surrogate(u16 cp)
	{
		return (cp >= LEAD_SURROGATE_MIN && cp <= TRAIL_SURROGATE_MAX);
	}

	template <typename u32>
	inline bool is_code_point_valid(u32 cp)
	{
		return (cp <= CODE_POINT_MAX && !is_surrogate(cp));
	}

	template<bool B, class T = void>
	using EnableIf = typename enable_if<B, T>::type;

	template<typename UtfCp> basic_string<char> wide_to_char(UtfCp cp)
	{
		basic_string<char> result;

		if (!is_code_point_valid(cp))
			throw invalid_argument("");

		if (cp < 0x80)               // one octet
			result += cp;
		else if (cp < 0x800)         // two octets
		{
			result += (cp >> 6)            | 0xc0;
			result += (cp & 0x3f)          | 0x80;
		}
		else if (cp < 0x10000)       // three octets
		{
			result += (cp >> 12)           | 0xe0;
			result += ((cp >> 6) & 0x3f)   | 0x80;
			result += (cp & 0x3f)          | 0x80;
		}
		else                                // four octets
		{
			result += (cp >> 18)           | 0xf0;
			result += ((cp >> 12) & 0x3f)  | 0x80;
			result += ((cp >> 6) & 0x3f)   | 0x80;
			result += (cp & 0x3f)          | 0x80;
		}

		return result;
	}

	uint_fast32_t surrogate_to_wide(uint16_t leading_surrogate, uint16_t trailing_surrogate)
	{
		// Take care of surrogate pairs first
		if (!is_lead_surrogate(leading_surrogate) || !is_trail_surrogate(trailing_surrogate))
			throw invalid_argument("");

		return (leading_surrogate << 10) + trailing_surrogate + SURROGATE_OFFSET;
	}

	template<typename Ch, typename enable_if<sizeof(Ch) == 2>::type...>
	basic_string<Ch> wide_convert(uint_fast16_t leading_surrogate, uint_fast16_t trailing_surrogate)
	{
		return basic_string<Ch> { static_cast<Ch>(leading_surrogate), static_cast<Ch>(trailing_surrogate) };
	}

	template<typename Ch, typename enable_if<sizeof(Ch) == 4>::type...>
	basic_string<Ch> wide_convert(uint_fast16_t leading_surrogate, uint_fast16_t trailing_surrogate)
	{
		return basic_string<Ch> { static_cast<Ch>(surrogate_to_wide(leading_surrogate, trailing_surrogate)) };
	}
}

bool utf::is_lead_surrogate(uint_fast16_t cp)
{
	return (cp >= LEAD_SURROGATE_MIN && cp <= LEAD_SURROGATE_MAX);
}

bool utf::is_trail_surrogate(uint_fast16_t cp)
{
	return (cp >= TRAIL_SURROGATE_MIN && cp <= TRAIL_SURROGATE_MAX);
}

template<> basic_string<char> utf::convert(uint_fast16_t cp)
{
	return wide_to_char(cp);
}

template<> basic_string<char> utf::convert(uint_fast16_t leading_surrogate, uint_fast16_t trailing_surrogate)
{
	return wide_to_char(surrogate_to_wide(leading_surrogate, trailing_surrogate));
}

template<> basic_string<wchar_t> utf::convert(uint_fast16_t leading_surrogate, uint_fast16_t trailing_surrogate)
{
	return wide_convert<wchar_t>(leading_surrogate, trailing_surrogate);
}

template<> basic_string<char16_t> utf::convert(uint_fast16_t leading_surrogate, uint_fast16_t trailing_surrogate)
{
	return wide_convert<char16_t>(leading_surrogate, trailing_surrogate);
}

template<> basic_string<char32_t> utf::convert(uint_fast16_t leading_surrogate, uint_fast16_t trailing_surrogate)
{
	return wide_convert<char32_t>(leading_surrogate, trailing_surrogate);
}
